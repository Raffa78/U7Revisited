--------------------------------------------------------------------------------
ENGINE
--------------------------------------------------------------------------------

DISPLAY
-------

*  Support any and all resolutions.  Default to 1024x768 for 4:3 screens and
   1280x720 for 16:9 or 16:10 screens.  Default to fullscreen.

+  Make sure we can switch between fullscreen and windowed live.

*  Enumerate resolutions in options screen; let player pick one.

+  Change resolutions live.

*  Rebuild texture cache on resolution change.

*  Recreate view frustum on resolution change.


GUI
---

+  Implement "float to corner" or "float to side"; instead of giving XY
   coordinates, the GUI is told where on the screen it should appear and
   calculates its own coordinates.  If the resolution changes, it should be
   possible recalculate the XY on the fly.

+  Add ability to change GUI scale on the fly.

*  GUI parameters should be loadable from an XML file.

*  Text Button Working
*  Text Button Scaling - Requires scaling fonts.
*  Text Button loaded from XML

+  Icon Button Working
+  Icon Button Scaling
*  Icon Button loaded from XML

+  Scrollbar Working
*  Scrollbar Scaling
*  Scrollbar loaded from XML

*  Radio Buttons Working
*  Radio Buttons Scaling
*  Radio Buttons loaded from XML

*  Check Box Working
*  Check Box Scaling
*  Radio Buttons loaded from XML

*  Text Input Working
*  Text Input Scaling - Requires scaling fonts.
*  Text Input loaded from XML

+  Panel Working
+  Panel Scaling
+  Panel loaded from XML

+  Image Working
+  Image Scaling
*  Image Loaded from XML


NETWORKING
----------

+  Basic cross-platform client/server connection.

+  Ability to specify port/server

*  Support for listen server


FONTS
-----

+  Scaling fonts.

*  Font animation.


PARTICLE SYSTEM
---------------

+  Basic particle system 

*  Scriptable from Lua


--------------------------------------------------------------------------------
PLANITIA
--------------------------------------------------------------------------------

TERRAIN
-------

*  Make one buffer for each type of terrain.

*  Split the terrain types into their own buffers.

*  Draw the terrain types separately (this WILL impact the framerate; not much
   for it).

*  Implement the cell system so that different terrain types can be marked in
   each cell and special effects (like timers) can be implemented.

*  Flowers, trees and butterflies are not game units.  They are terrain
   accessories and should be treated accordingly.  The gameplay should not know
   anything about them.

*  Stop ghettoing our visibility and get a real quadtree in.

+  Figure out why we're getting odd stuff at the edge of the terrain.

*  Fix terrain manipulation.


SKYBOX
------

*  Put a cloudplane behind the terrain that moves with the terrain - but not as
   much, to suggest it's far away.  Make it move or morph.


WATER
-----

*  Implement water in a similar manner to that in Planitia DirectX.  Consider
   making it reflective of the skysphere.  That could look boss.


GUIS
----

*  Server Lobby
   *  Assign clients unique identifiers as they join
   *  Only let a certain number of clients join
   *  Allow chat
   *  Allow team color pick
   *  Allow name change
   *  Allow server to change game options
   *  Allow server to choose map

*  Client Lobby
   *  Allow chat
   *  Allow team color pick
   *  Allow name change


Planitia has three GUIs - the main menu, the in-game options menu and the main
game menu.  

*  Main Menu

*  In-Game

*  Options


UNITS
-----

*  Units should be scriptable from Lua.

*  Walker
   *  Draws correctly
   *  Functions correctly
   *  Plays sound

*  House
   *  Draw correctly
   *  Functions correctly
   *  Plays sound

*  Rock
   *  Draws correctly
   *  Functions correctly
   *  Plays sound?

*  General
   *  Draws correctly
   *  Functions correctly
   *  Plays sound

*  Warrior
   *  Draws correctly
   *  Functions correctly
   *  Plays sound

*  Barbarian
   *  Draws correctly
   *  Functions correctly
   *  Plays sound

*  Archer
   *  Draws correctly
   *  Functions correctly
   *  Plays sound

*  Bird
   *  Draws correctly
   *  Functions correctly
   *  Plays sound

*  Sheep
   *  Draws correctly
   *  Functions correctly
   *  Plays sound

*  Lightning bolt
   *  Draw correctly
   *  Functions correctly
   *  Plays sound

*  Earthquake
   *  Draw correctly
   *  Functions correctly
   *  Plays sound

*  Tornado
   *  Draw correctly
   *  Functions correctly
   *  Plays sound

*  Flamering
   *  Draw correctly
   *  Functions correctly
   *  Plays sound

*  Meteor
   *  Draw correctly
   *  Functions correctly
   *  Plays sound

*  Hero
   *  Draw correctly
   *  Functions correctly
   *  Plays sound

*  Volcano
   *  Draw correctly
   *  Functions correctly
   *  Plays sound

*  Flamestrike
   *  Draw correctly
   *  Functions correctly
   *  Plays sound


GOD POWERS
----------

+  Basic god power class and system in

*  God powers deduct mana and instigate powers, either by buffing or creating units

*  Godpowers scriptable from Lua.
   *  Manipulate the terrain verts
   *  Change terrain tile types
   *  Create units
   *  Buff/debuff units

*  Flatten - Terrain Alterer
   + Button Created
   + Basic Functionality
   - Unit Created

*  Earthquake - Unit
   + Button Created
   + Basic Functionality
   + Unit Created

*  Celerity - Buffer
   + Temp Button Created
   + Basic Functionality
   - Unit Created

*  Bless Land - Terrain Alterer
   + Button Created
   + Basic Functionality
   * Unit Created

*  Cleanse - Buffer
   * Button Created
   + Basic Functionality
   - Unit Created

*  Oakskin - Buffer
   * Button Created
   + Basic Functionality
   - Unit Created

*  Lightning - Unit
   + Button Created
   + Basic Functionality
   * Unit Created

*  Hypnotize - Buffer
   * Button Created
   + Basic Functionality
   - Unit Created

*  Tornado - Unit
   * Button Created
   + Basic Functionality
   * Unit Created

*  Flamering - Unit, Buffer
   * Button Created
   + Basic Functionality
   * Unit Created

*  Bloodlust - Buffer
   * Button Created
   + Basic Functionality
   * Unit Created

*  Meteor - Unit
   + Button Created
   + Basic Functionality
   * Unit Created

*  Plague - Buffer
   * Button Created
   + Basic Functionality
   * Unit Created

*  Knight - Unit
   * Button Created
   * Basic Functionality
   * Unit Created

*  Armageddon - Unit
   + Button Created
   * Basic Functionality
   * Unit Created

*  Volcano - Unit, Buffer, Terrain Alterer
   + Button Created
   * Basic Functionality
   * Unit Created

*  Stone Rain - Terrain Alterer
   + Button Created
   + Basic Functionality
   * Unit Created

*  Swamp - Terrain Alterer
   + Button Created
   + Basic Functionality
   - Unit Created

*  HealingLight - Unit, Buffer
   + Button Created
   + Basic Functionality
   * Unit Created (for effect)

*  Flamestrike - Unit, Buffer
   + Button Created
   * Basic Functionality
   * Unit Created



NETWORKING
----------

*  Once actual data swapping is implemented (see ENGINE, above) we need a system
   that allows us to easily control how often the game ticks and how often and
   when the computers swap.  This will be so that we can easily adjust these and
   get the best performance over the internet.

*  First, we need to know if a particular instance of the game is the client or
   server.

*  If server, this instance is player 0 always.

*  Server waits for clients to connect.  On connection the server assigns a
   player number to the client.

*  Server tells the client how many updates constitutes a game turn.

*  Once the game begins...

*  All clients (include the one running on the server) submit their events.  The
   turn cannot progress until every client either submits their event or submits
   that they don't have an event.

*  After getting events from every client, the server then sends all events for
   this update to all clients.

*  Upon receiving these updates, all clients update their simulations and
   proceed to the next turn.




SCRIPTING
---------

*  We will need some scripting even if we decide not to use it for godpowers.
   Basically, we need a system that will allow us to, from text or memory,
   set up a map, set up the gods, assign victory conditions, spawn units, use
   god powers, and bark either the gods or the units at various times.  A lot
   like a replay, except that we can't use replays for this; they're too
   complex.


GENERAL GAMEPLAY
----------------

*  Barks.  Barks for gods come from the corners of the screen.  Barks for the
   villagers hover over their heads.

*  Village growth.  A village will start with three walkers, one house and one
   field (this is not a unit, it's a special terrain type).  Walkers will walk
   to nearby fields and gather food.  Once the player has enough food in his
   bank, a new walker is created.  This walker will be tagged to a house -
   unless all houses already have five walkers.  If so, this walker will find
   a square of flat land nearby (at least one square from any existing house)
   and build a new house, which it will then attach itself to.  It will then
   start gathering food from a nearby field - unless all are full, in which case
   it will create a field nearby (adjacent to ether an existing field or house)
   and start gathering from that.



SINGLE PLAYER
-------------







